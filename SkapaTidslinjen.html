<!DOCTYPE html>
<html lang="sv">
<head>
    <meta charset="UTF-8">
    <title>Interaktiv Tidslinje</title>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/inter/3.19.3/inter.css" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/lodash.js/4.17.21/lodash.min.js"></script>
    <style>
        /* Allmänna stilar */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        /* Döljer period-labels-container när klassen hidden är tillagd */
        #period-labels-container.hidden {
            display: none;
        }
#period-labels-container {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    pointer-events: none;
    overflow: visible;
}

.period-label {
    position: absolute;
    transform: translate(-50%, 0);
    color: white;
    font-family: 'Inter', sans-serif;
    text-shadow: 0 2px 4px rgba(0, 0, 0, 0.5);
    pointer-events: none;
    white-space: nowrap;
    transition: opacity 0.3s ease;
    z-index: 10;
    font-size: 14px;
    font-weight: 500;
}

        body {
            margin: 0;
            padding: 20px;
            background-color: #0a0a0a;
            color: white;
            font-family: 'Inter', sans-serif;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .main-container {
            display: flex;
            flex-direction: column;
            gap: 1rem;
            padding: 1rem;
            max-width: 1200px;
            width: 100%;
        }

        .canvas-container {
            position: relative;
            width: 100%;
            background-color: #111;
            border-radius: 0.5rem;
            overflow: visible;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        canvas {
            width: 100%;
            cursor: grab;
            display: block;
        }

        canvas:active {
            cursor: grabbing;
        }

        #period-labels-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            /* Höjden kommer nu att anpassas dynamiskt */
            pointer-events: none;
            overflow: hidden;
        }

        .period-label {
            position: absolute;
            /* Top justeras dynamiskt via JavaScript */
            transform: translate(-50%, 0);
            color: white;
            font-family: 'Inter', sans-serif;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.5);
            pointer-events: none;
            white-space: nowrap;
            transition: opacity 0.3s ease;
            z-index: 10;
            font-size: 14px; /* Anpassa efter behov */
        }

        .control-panel {
            background-color: #1a1a1a;
            border-radius: 0.5rem;
            padding: 1rem;
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }

        .input-group {
            display: flex;
            gap: 1rem;
            align-items: center;
        }

        input {
            background-color: #333;
            border: 1px solid #444;
            color: white;
            padding: 0.5rem 1rem;
            border-radius: 0.25rem;
            font-family: 'Inter', sans-serif;
        }

        input[type="text"] {
            flex: 1;
        }

        input[type="number"] {
            width: 120px;
        }

        button {
            background-color: #2563eb;
            color: white;
            padding: 0.5rem 1rem;
            border: none;
            border-radius: 0.25rem;
            cursor: pointer;
            font-family: 'Inter', sans-serif;
            transition: background-color 0.2s;
        }

        button:hover:not(:disabled) {
            background-color: #1d4ed8;
        }

        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        button.secondary {
            background-color: #374151;
        }

        button.secondary:hover:not(:disabled) {
            background-color: #4b5563;
        }

        .toggle-group {
            display: flex;
            gap: 0.5rem;
        }

        .toggle-button {
            background-color: #374151;
            padding: 0.5rem 1rem;
            border-radius: 0.25rem;
            cursor: pointer;
        }

        .toggle-button.active {
            background-color: #059669;
        }

        .modal {
            display: none;
            position: fixed;
            inset: 0;
            background-color: rgba(0, 0, 0, 0.75);
            align-items: center;
            justify-content: center;
            z-index: 50;
        }

        .modal.active {
            display: flex;
        }

        .modal-content {
            background-color: #1a1a1a;
            padding: 1.5rem;
            border-radius: 0.5rem;
            width: 100%;
            max-width: 500px;
            position: relative;
        }

        .modal-header {
            margin-bottom: 1rem;
            font-size: 1.25rem;
            font-weight: 600;
        }

        .modal-body {
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }

        .modal-footer {
            display: flex;
            justify-content: space-between;
            gap: 0.5rem;
            margin-top: 1rem;
        }

        .error-message {
            color: #ef4444;
            font-size: 0.875rem;
            margin-top: 0.5rem;
        }

        [aria-invalid="true"] {
            border-color: #ef4444;
        }

        /* Styles för Event Manager Pop-out */
        #event-manager-modal .modal-content {
            max-width: 600px;
            max-height: 80vh;
            overflow-y: auto;
        }

        .event-list {
            list-style: none;
            padding: 0;
            margin: 0;
        }

        .event-list li {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0.5rem 0;
            border-bottom: 1px solid #444;
        }

        .event-list li:last-child {
            border-bottom: none;
        }

        .event-list label {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .close-modal-button {
            background-color: #ef4444;
        }

        .close-modal-button:hover:not(:disabled) {
            background-color: #dc2626;
        }
    </style>
</head>
<body>
    <div class="main-container">
        <div class="canvas-container">
            <canvas id="timeline"></canvas>
            <div id="period-labels-container"></div>
        </div>

        <div class="control-panel">
            <div class="input-group">
                <input type="text" id="event-name" placeholder="Händelsens namn">
                <input type="number" id="years-ago" placeholder="År sedan">
                <button id="add-event">Lägg till händelse</button>
            </div>
            
            <div class="error-message" id="error-message"></div>
            
            <div class="toggle-group">
                <button id="toggle-periods" class="toggle-button">
                    Visa geologiska perioder
                </button>
                <button id="toggle-scale" class="toggle-button">
                    Visa skalstreck
                </button>
                <button id="manage-events" class="toggle-button">
                    Hantera händelser
                </button>
            </div>
        </div>
    </div>

    <!-- Edit Modal -->
    <div id="edit-modal" class="modal">
        <div class="modal-content">
            <div class="modal-header">Redigera händelse</div>
            <div class="modal-body">
                <input type="text" id="edit-name" placeholder="Händelsens namn">
                <input type="number" id="edit-years" placeholder="År sedan">
                <div class="error-message" id="edit-error-message"></div>
            </div>
            <div class="modal-footer">
                <button id="delete-event" class="secondary">Ta bort</button>
                <div class="button-group">
                    <button id="close-modal" class="secondary">Avbryt</button>
                    <button id="save-edit">Spara</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Event Manager Pop-out Modal -->
    <div id="event-manager-modal" class="modal">
        <div class="modal-content">
            <div class="modal-header">Hantera händelser</div>
            <div class="modal-body">
                <ul class="event-list" id="event-list">
                    <!-- Dynamiskt innehåll -->
                </ul>
            </div>
            <div class="modal-footer">
                <button id="close-event-manager" class="secondary">Stäng</button>
            </div>
        </div>
    </div>

    <script>
    // Konstanter och konfiguration

    const CONSTANTS = {
        TEXT: {
            VERTICAL_SPACING: 80,
            MIN_HORIZONTAL_SPACING: 200,
            PADDING: 20,
            MAX_LEVELS: 5,
        },
        VIEWPORT: {
            DEFAULT_PADDING: 0.1,
            MIN_HEIGHT: 600,
            ANIMATION_DURATION: 500,
        }
    };

    // Geologiska perioder
    const PERIODS = [
        { 
            name: 'Kambrium',
            start: 541000000, 
            end: 485000000, 
            color: 'rgba(70, 130, 180, 0.15)',
            textColor: 'rgba(70, 130, 180, 0.9)'
        },
        { 
            name: 'Ordovicium',
            start: 485000000, 
            end: 443000000, 
            color: 'rgba(60, 179, 113, 0.15)',
            textColor: 'rgba(60, 179, 113, 0.9)'
        },
        { 
            name: 'Silur',
            start: 443000000, 
            end: 419000000, 
            color: 'rgba(34, 139, 34, 0.15)',
            textColor: 'rgba(34, 139, 34, 0.9)'
        },
        { 
            name: 'Devon',
            start: 419000000, 
            end: 359000000, 
            color: 'rgba(255, 165, 0, 0.15)',
            textColor: 'rgba(255, 165, 0, 0.9)'
        },
        { 
            name: 'Karbon',
            start: 359000000, 
            end: 299000000, 
            color: 'rgba(128, 0, 128, 0.15)',
            textColor: 'rgba(128, 0, 128, 0.9)'
        },
        { 
            name: 'Perm',
            start: 299000000, 
            end: 252000000, 
            color: 'rgba(220, 20, 60, 0.15)',
            textColor: 'rgba(220, 20, 60, 0.9)'
        },
        // Mesozoikum Perioder
        { 
            name: 'Trias',
            start: 252000000, 
            end: 201000000, 
            color: 'rgba(144, 238, 144, 0.15)',
            textColor: 'rgba(144, 238, 144, 0.9)'
        },
        { 
            name: 'Jura',
            start: 201000000, 
            end: 145000000, 
            color: 'rgba(60, 179, 113, 0.15)',
            textColor: 'rgba(60, 179, 113, 0.9)'
        },
        { 
            name: 'Krita',
            start: 145000000, 
            end: 66000000, 
            color: 'rgba(46, 139, 87, 0.15)',
            textColor: 'rgba(46, 139, 87, 0.9)'
        },
        // Kenozoikum Perioder
        { 
            name: 'Paleogen',
            start: 66000000, 
            end: 23000000, 
            color: 'rgba(173, 216, 230, 0.15)',
            textColor: 'rgba(173, 216, 230, 0.9)'
        },
        { 
            name: 'Neogen',
            start: 23000000, 
            end: 2600000, 
            color: 'rgba(135, 206, 250, 0.15)',
            textColor: 'rgba(135, 206, 250, 0.9)'
        },
        { 
            name: 'Kvartär',
            start: 2600000, 
            end: 0, 
            color: 'rgba(255, 215, 0, 0.15)',
            textColor: 'rgba(255, 215, 0, 0.9)'
        }
    ];

    // ViewportManager - Hanterar canvas och viewport
    const ViewportManager = {
        state: {
            startYear: 0,
            endYear: 1000000,
            scale: 1,
            centerYear: 500000,
            isDragging: false,
            dragStart: null
        },

        canvas: null,
        ctx: null,
        
        initialize(canvasElement) {
            this.canvas = canvasElement;
            this.ctx = canvasElement.getContext('2d');
            this.setupCanvas();
            this.setupEventListeners();
            this.resetView();
        },

        setupCanvas() {
            const updateCanvasSize = () => {
                const container = this.canvas.parentElement;
                const dpr = window.devicePixelRatio || 1;

                // Beräkna och centrera vertikalt
                const requiredHeight = this.requiredHeight || CONSTANTS.VIEWPORT.MIN_HEIGHT;
                const containerHeight = Math.max(requiredHeight, container.offsetHeight);
                
                container.style.height = `${containerHeight}px`;
                this.canvas.style.marginTop = `${(containerHeight - requiredHeight) / 2}px`;

                // Uppdatera canvas dimensioner
                this.canvas.width = container.offsetWidth * dpr;
                this.canvas.height = requiredHeight * dpr;
                this.canvas.style.width = `${container.offsetWidth}px`;
                this.canvas.style.height = `${requiredHeight}px`;

                // Skala context för HiDPI
                this.ctx.scale(dpr, dpr);
            };

            // Initial storlek
            updateCanvasSize();

            // Observera storleksförändringar
            const resizeObserver = new ResizeObserver(_.debounce(() => {
                updateCanvasSize();
                TimelineRenderer.requestRender();
            }, 100));
            
            resizeObserver.observe(this.canvas.parentElement);
        },

        adjustCanvasHeight(requiredHeight) {
            this.requiredHeight = requiredHeight;
            this.setupCanvas();
        },

        updateViewport(newViewport, animate = false) {
            if (animate) {
                const startState = { ...this.state };
                const startTime = performance.now();
                
                const animateStep = (currentTime) => {
                    const elapsed = currentTime - startTime;
                    const progress = Math.min(elapsed / CONSTANTS.VIEWPORT.ANIMATION_DURATION, 1);
                    
                    const eased = progress < .5 ? 
                        4 * progress * progress * progress : 
                        1 - Math.pow(-2 * progress + 2, 3) / 2;
                    
                    this.state = {
                        startYear: startState.startYear + (newViewport.startYear - startState.startYear) * eased,
                        endYear: startState.endYear + (newViewport.endYear - startState.endYear) * eased,
                        scale: startState.scale + (newViewport.scale - startState.scale) * eased,
                        centerYear: startState.centerYear + (newViewport.centerYear - startState.centerYear) * eased
                    };
                    
                    TimelineRenderer.requestRender();
                    
                    if (progress < 1) {
                        requestAnimationFrame(animateStep);
                    }
                };
                
                requestAnimationFrame(animateStep);
            } else {
                this.state = { ...this.state, ...newViewport };
                TimelineRenderer.requestRender();
            }
        },

        setupEventListeners() {
            // Drag and drop
            this.canvas.addEventListener('mousedown', (e) => {
                this.state.isDragging = true;
                this.state.dragStart = {
                    x: e.offsetX,
                    year: this.pixelToYear(e.offsetX)
                };
                this.canvas.style.cursor = 'grabbing';
            });

            this.canvas.addEventListener('mousemove', _.throttle((e) => {
                if (!this.state.isDragging || !this.state.dragStart) return;
                
                const deltaX = e.offsetX - this.state.dragStart.x;
                const deltaYear = this.pixelToYear(e.offsetX) - this.state.dragStart.year;

                this.state.startYear -= deltaYear;
                this.state.endYear -= deltaYear;
                this.state.dragStart.x = e.offsetX;
                this.state.dragStart.year = this.pixelToYear(e.offsetX);

                TimelineRenderer.requestRender();
            }, 16)); // Approximately 60fps

            const endDrag = () => {
                this.state.isDragging = false;
                this.state.dragStart = null;
                this.canvas.style.cursor = 'grab';
            };

            this.canvas.addEventListener('mouseup', endDrag);
            this.canvas.addEventListener('mouseleave', endDrag);
        },

        yearToPixel(year) {
            const width = this.canvas.width / window.devicePixelRatio;
            const span = this.state.endYear - this.state.startYear;
            if (span === 0) {
                console.error('yearToPixel: endYear och startYear är lika.');
                return 0; // Eller ett annat lämpligt värde
            }
            const pixel = ((this.state.endYear - year) / span) * width;
            if (isNaN(pixel) || !isFinite(pixel)) {
                console.error(`yearToPixel: Ogiltigt pixelvärde för år ${year}: ${pixel}`);
                return 0;
            }
            return pixel;
        },

        pixelToYear(pixel) {
            const width = this.canvas.width / window.devicePixelRatio;
            const span = this.state.endYear - this.state.startYear;
            if (span === 0) {
                console.error('pixelToYear: endYear och startYear är lika.');
                return this.state.startYear;
            }
            const year = this.state.startYear + (pixel / width) * span;
            if (isNaN(year) || !isFinite(year)) {
                console.error(`pixelToYear: Ogiltigt år för pixel ${pixel}: ${year}`);
                return this.state.startYear;
            }
            return year;
        },

        resetView() {
            const optimalViewport = this.calculateOptimalViewport(EventManager.getVisibleEvents());
            this.state = { ...this.state, ...optimalViewport };
        },

        calculateOptimalViewport(events) {
            const MIN_VIEW_SPAN = 10; // Minsta vybredd för att undvika för snäv vy
            const PADDING_RATIO = 0.2; // Öka padding till 20% för mer luft
            
            if (!events.length) {
                return {
                    startYear: -MIN_VIEW_SPAN, // Börja före 0 för att ge padding även åt vänster
                    endYear: MIN_VIEW_SPAN,
                    scale: 1,
                    centerYear: 0
                };
            }
        
            if (events.length === 1) {
                const event = events[0];
                
                // Specialhantering för 0 år och mycket små värden
                if (event.yearsAgo <= MIN_VIEW_SPAN) {
                    // För nutidshändelser, se till att vi har padding på båda sidor om 0
                    const viewSpan = MIN_VIEW_SPAN * 2;
                    return {
                        startYear: -viewSpan / 2, // Negativ startpunkt ger padding till vänster om 0
                        endYear: viewSpan / 2,    // Positiv endpoint ger padding till höger om 0
                        scale: 1,
                        centerYear: event.yearsAgo
                    };
                }
                
                // För övriga värden, beräkna lämplig vybredd baserat på storleksordning
                const magnitude = Math.floor(Math.log10(event.yearsAgo));
                const baseViewSpan = Math.pow(10, magnitude);
                
                // Lägg till padding
                const paddedViewSpan = baseViewSpan * (1 + 2 * PADDING_RATIO);
                const halfSpan = paddedViewSpan / 2;
                
                // Centrera vyn runt händelsen med padding
                // Om händelsen är nära 0, låt vyn gå förbi 0 för att behålla centreringen
                const idealStart = event.yearsAgo - halfSpan;
                const start = idealStart;  // Ta bort Math.max(0, ...) för att tillåta negativa år
                const end = start + paddedViewSpan;
                
                return {
                    startYear: start,
                    endYear: end,
                    scale: 1,
                    centerYear: event.yearsAgo
                };
            }
        
            // För flera händelser
            const years = events.map(e => e.yearsAgo);
            const minYear = Math.min(...years);
            const maxYear = Math.max(...years);
            const timespan = maxYear - minYear;
            const padding = Math.max(timespan * PADDING_RATIO, MIN_VIEW_SPAN);
        
            // Tillåt negativt startår för att ge padding även när minYear är 0
            return {
                startYear: minYear - padding,
                endYear: maxYear + padding,
                scale: 1,
                centerYear: (minYear + maxYear) / 2
            };
        }
    };
    // TextPlacementManager - Hanterar textplacering och kollisionsdetektering
    const TextPlacementManager = {
        cache: {
            viewport: null,
            placements: new Map()
        },
        maxLevelAbove: 0,
        maxLevelBelow: 0,
    
        calculateTextDimensions(ctx, event) {
            ctx.save();
            ctx.font = '14px Inter';
            const nameMetrics = ctx.measureText(event.name);
            const yearText = `${event.yearsAgo.toLocaleString()} år`;
            const yearMetrics = ctx.measureText(yearText);
            ctx.restore();
            
            return {
                width: Math.max(nameMetrics.width, yearMetrics.width) + CONSTANTS.TEXT.PADDING * 2,
                height: 60
            };
        },
    
        calculatePlacements(ctx, events) {
            const currentViewport = { ...ViewportManager.state };
            // Kontrollera om viewporten har ändrats
            if (this.cache.viewport && _.isEqual(this.cache.viewport, currentViewport)) {
                return this.cache.placements;
            }
    
            // Utför beräkningarna
            const placements = new Map();
            const height = ctx.canvas.height / window.devicePixelRatio;
            const width = ctx.canvas.width / window.devicePixelRatio;
            const centerY = height / 2;
            
            // Sortera händelser baserat på x-position
            const sortedEvents = [...events].sort((a, b) => 
                ViewportManager.yearToPixel(a.yearsAgo) - ViewportManager.yearToPixel(b.yearsAgo)
            );
    
            // Skapa två arrays för händelser ovanför och under tidslinjen
            const aboveEvents = [];
            const belowEvents = [];
            
            // Fördela händelser jämnt ovanför och under
            sortedEvents.forEach((event, index) => {
                if (index % 2 === 0) {
                    aboveEvents.push(event);
                } else {
                    belowEvents.push(event);
                }
            });
    
            this.maxLevelAbove = 0;
            this.maxLevelBelow = 0;
    
            // Funktion för att placera händelser på en sida
            const placeEvents = (eventsArray, isAbove) => {
                let currentLevel = 0;
                let lastX = -Infinity;
    
                eventsArray.forEach(event => {
                    const x = ViewportManager.yearToPixel(event.yearsAgo);
                    const textDims = this.calculateTextDimensions(ctx, event);
                    
                    // Återställ level om det finns tillräckligt horisontellt utrymme
                    if (x - lastX > CONSTANTS.TEXT.MIN_HORIZONTAL_SPACING) {
                        currentLevel = 0;
                    } else {
                        currentLevel++;
                    }
    
                    // Uppdatera maxnivåer
                    if (isAbove) {
                        this.maxLevelAbove = Math.max(this.maxLevelAbove, currentLevel);
                    } else {
                        this.maxLevelBelow = Math.max(this.maxLevelBelow, currentLevel);
                    }
    
                    // Beräkna y-position
                    const baseOffset = CONSTANTS.TEXT.VERTICAL_SPACING;
                    const levelOffset = currentLevel * CONSTANTS.TEXT.VERTICAL_SPACING;
                    const yOffset = isAbove ? -(baseOffset + levelOffset) : (baseOffset + levelOffset);
                    
                    // Justera x-position för textbox om den är nära kanten
                    const halfWidth = textDims.width / 2;
                    let adjustedX = x;
                    
                    // Se till att textboxen inte går utanför canvasen
                    if (x - halfWidth < 0) {
                        adjustedX = halfWidth; // Justera åt höger om för nära vänsterkanten
                    } else if (x + halfWidth > width) {
                        adjustedX = width - halfWidth; // Justera åt vänster om för nära högerkanten
                    }
                    
                    const placement = {
                        x: adjustedX,
                        y: centerY + yOffset,
                        width: textDims.width,
                        height: textDims.height,
                        isAbove,
                        level: currentLevel,
                        originalX: x // Spara originalpositionen för händelselinjen
                    };
    
                    placements.set(event.id, placement);
                    lastX = x + textDims.width;
                });
            };
    
            // Placera händelser på båda sidor
            placeEvents(aboveEvents, true);
            placeEvents(belowEvents, false);
    
            // Uppdatera cache
            this.cache.viewport = { ...currentViewport };
            this.cache.placements = placements;
    
            return placements;
        }
    };
    
    // EventManager - Hanterar händelser och användarinteraktion
    const EventManager = {
        events: [],
        selectedEvent: null,
        
        elements: {
            nameInput: null,
            yearsInput: null,
            addButton: null,
            errorMessage: null,
            modal: null,
            editNameInput: null,
            editYearsInput: null,
            editErrorMessage: null,
            deleteButton: null,
            closeModalButton: null,
            saveEditButton: null,
            eventManagerModal: null,
            eventList: null,
            closeEventManagerButton: null,
            manageEventsButton: null
        },
    
        initialize() {
            // Koppla DOM-element
            this.elements = {
                nameInput: document.getElementById('event-name'),
                yearsInput: document.getElementById('years-ago'),
                addButton: document.getElementById('add-event'),
                errorMessage: document.getElementById('error-message'),
                modal: document.getElementById('edit-modal'),
                editNameInput: document.getElementById('edit-name'),
                editYearsInput: document.getElementById('edit-years'),
                editErrorMessage: document.getElementById('edit-error-message'),
                deleteButton: document.getElementById('delete-event'),
                closeModalButton: document.getElementById('close-modal'),
                saveEditButton: document.getElementById('save-edit'),
                eventManagerModal: document.getElementById('event-manager-modal'),
                eventList: document.getElementById('event-list'),
                closeEventManagerButton: document.getElementById('close-event-manager'),
                manageEventsButton: document.getElementById('manage-events')
            };
    
            this.setupEventListeners();
            this.setupCanvasHover();
        },
    
        setupEventListeners() {
            // Add event
            this.elements.addButton.addEventListener('click', () => this.addEvent());
            
            // Input validering
            this.elements.nameInput.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') this.addEvent();
            });
    
            this.elements.yearsInput.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') this.addEvent();
            });
    
            // Modal kontroller
            this.elements.closeModalButton.addEventListener('click', () => this.closeModal());
            this.elements.saveEditButton.addEventListener('click', () => this.saveEdit());
            this.elements.deleteButton.addEventListener('click', () => this.deleteEvent());
    
            // Escape för att stänga modal
            document.addEventListener('keydown', (e) => {
                if (e.key === 'Escape') {
                    if (this.elements.modal.classList.contains('active')) {
                        this.closeModal();
                    }
                    if (this.elements.eventManagerModal.classList.contains('active')) {
                        this.closeEventManager();
                    }
                }
            });
    
            // Event Manager Modal
            this.elements.manageEventsButton.addEventListener('click', () => this.openEventManager());
            this.elements.closeEventManagerButton.addEventListener('click', () => this.closeEventManager());
        },
    
        addEvent() {
            const name = this.elements.nameInput.value.trim();
            const yearsAgo = parseInt(this.elements.yearsInput.value);
    
            console.log('Lägger till händelse:', name, yearsAgo);
    
            if (!this.validateEventInput(name, yearsAgo)) return;
    
            const newEvent = {
                id: Date.now(),
                name: name,
                yearsAgo: yearsAgo,
                color: `hsl(${(this.events.length * 137.5) % 360}, 70%, 60%)`,
                visible: true
            };
    
            this.events.push(newEvent);
            this.events.sort((a, b) => a.yearsAgo - b.yearsAgo);
    
            // Reset form
            this.elements.nameInput.value = '';
            this.elements.yearsInput.value = '';
            this.elements.errorMessage.textContent = '';
    
            // Uppdatera viewport och rendera
            const newViewport = ViewportManager.calculateOptimalViewport(this.getVisibleEvents());
            ViewportManager.updateViewport(newViewport, true);
    
            // Update event manager list if open
            if (this.elements.eventManagerModal.classList.contains('active')) {
                this.renderEventList();
            }
        },
    
        validateEventInput(name, yearsAgo, isEdit = false) {
            const errorElement = isEdit ? this.elements.editErrorMessage : this.elements.errorMessage;
            
            if (!name) {
                this.showError('Ange ett namn för händelsen', isEdit);
                return false;
            }
    
            if (isNaN(yearsAgo) || yearsAgo < 0) {
                this.showError('Ange ett giltigt årtal', isEdit);
                return false;
            }
    
            return true;
        },
    
        showError(message, isEdit = false) {
            const element = isEdit ? this.elements.editErrorMessage : this.elements.errorMessage;
            element.textContent = message;
            
            setTimeout(() => {
                if (element.textContent === message) {
                    element.textContent = '';
                }
            }, 3000);
        },
    
        handleCanvasClick(x, y) {
            if (ViewportManager.state.isDragging) return;
    
            const height = ViewportManager.canvas.height / window.devicePixelRatio;
            const centerY = height / 2;
            const clickRadius = 10;
            
            const clickedEvent = this.getVisibleEvents().find(event => {
                const eventX = ViewportManager.yearToPixel(event.yearsAgo);
                const distance = Math.sqrt(Math.pow(eventX - x, 2) + Math.pow(centerY - y, 2));
                return distance <= clickRadius;
            });
    
            if (clickedEvent) {
                this.selectedEvent = clickedEvent;
                this.showEditModal(clickedEvent);
            } else {
                this.selectedEvent = null;
            }
        },
    
        showEditModal(event) {
            this.elements.editNameInput.value = event.name;
            this.elements.editYearsInput.value = event.yearsAgo;
            this.elements.editErrorMessage.textContent = '';
            this.elements.modal.classList.add('active');
        },
    
        closeModal() {
            this.elements.modal.classList.remove('active');
            this.selectedEvent = null;
            TimelineRenderer.requestRender();
        },
    
        saveEdit() {
            const name = this.elements.editNameInput.value.trim();
            const yearsAgo = parseInt(this.elements.editYearsInput.value);
    
            if (!this.validateEventInput(name, yearsAgo, true)) return;
    
            const index = this.events.findIndex(e => e.id === this.selectedEvent.id);
            if (index !== -1) {
                this.events[index] = {
                    ...this.events[index],
                    name: name,
                    yearsAgo: yearsAgo
                };
    
                this.events.sort((a, b) => a.yearsAgo - b.yearsAgo);
                this.closeModal();
    
                // Uppdatera viewport om nödvändigt
                const newViewport = ViewportManager.calculateOptimalViewport(this.getVisibleEvents());
                ViewportManager.updateViewport(newViewport, true);
    
                // Update event manager list if open
                if (this.elements.eventManagerModal.classList.contains('active')) {
                    this.renderEventList();
                }
            }
        },
    
        deleteEvent() {
            if (!this.selectedEvent) return;
    
            const index = this.events.findIndex(e => e.id === this.selectedEvent.id);
            if (index !== -1) {
                this.events.splice(index, 1);
                this.closeModal();
    
                // Uppdatera viewport
                if (this.getVisibleEvents().length > 0) {
                    const newViewport = ViewportManager.calculateOptimalViewport(this.getVisibleEvents());
                    ViewportManager.updateViewport(newViewport, true);
                } else {
                    ViewportManager.resetView();
                    TimelineRenderer.requestRender();
                }
    
                // Update event manager list if open
                if (this.elements.eventManagerModal.classList.contains('active')) {
                    this.renderEventList();
                }
            }
        },
    
        getSelectedEventId() {
            return this.selectedEvent?.id;
        },
    
        setupCanvasHover() {
            const canvas = ViewportManager.canvas;
            canvas.addEventListener('mousemove', _.throttle((e) => {
                const rect = canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                const hoveredEvent = this.getEventAtPosition(x, y);
    
                let needsRender = false;
    
                this.events.forEach(event => {
                    if (hoveredEvent && event.id === hoveredEvent.id) {
                        if (!event.isHovered) {
                            event.isHovered = true;
                            needsRender = true;
                        }
                    } else if (event.isHovered) {
                        event.isHovered = false;
                        needsRender = true;
                    }
                });
    
                if (needsRender) {
                    TimelineRenderer.requestRender();
                }
            }, 100)); // Anpassa intervallet efter behov
        },
    
        getEventAtPosition(x, y) {
            const height = ViewportManager.canvas.height / window.devicePixelRatio;
            const centerY = height / 2;
            const hoverRadius = 10;
            
            return this.getVisibleEvents().find(event => {
                const eventX = ViewportManager.yearToPixel(event.yearsAgo);
                const distance = Math.sqrt(Math.pow(eventX - x, 2) + Math.pow(centerY - y, 2));
                return distance <= hoverRadius;
            });
        },
    
        getVisibleEvents() {
            return this.events.filter(event => event.visible);
        },
    
        openEventManager() {
            this.renderEventList();
            this.elements.eventManagerModal.classList.add('active');
        },
    
        closeEventManager() {
            this.elements.eventManagerModal.classList.remove('active');
        },
    
        renderEventList() {
            const eventList = this.elements.eventList;
            eventList.innerHTML = '';
    
            if (this.events.length === 0) {
                const li = document.createElement('li');
                li.textContent = 'Inga händelser tillagda.';
                eventList.appendChild(li);
                return;
            }
    
            const fragment = document.createDocumentFragment();
    
            this.events.forEach(event => {
                const li = document.createElement('li');
                
                const label = document.createElement('label');
                const checkbox = document.createElement('input');
                checkbox.type = 'checkbox';
                checkbox.checked = event.visible;
                checkbox.addEventListener('change', () => {
                    event.visible = checkbox.checked;
                    // Uppdatera viewport
                    const newViewport = ViewportManager.calculateOptimalViewport(this.getVisibleEvents());
                    ViewportManager.updateViewport(newViewport, true);
                });
                label.appendChild(checkbox);
    
                const span = document.createElement('span');
                span.textContent = `${event.name} (${event.yearsAgo.toLocaleString()} år)`;
                label.appendChild(span);
    
                li.appendChild(label);
                fragment.appendChild(li);
            });
    
            eventList.appendChild(fragment);
        }
    };
    
    // TimelineRenderer - Hanterar all rendering
    const TimelineRenderer = {
        initialize() {
            this.togglePeriods = false;
            this.toggleScale = false;
            this.needsRender = true;
            this.renderRequested = false;
            this.renderQueued = false;
            
            // Sätt upp toggle-knappar
            const periodsButton = document.getElementById('toggle-periods');
            const scaleButton = document.getElementById('toggle-scale');
            
            periodsButton.addEventListener('click', () => {
                this.togglePeriods = !this.togglePeriods;
                this.updateToggleButton(periodsButton, this.togglePeriods);
                this.togglePeriodsContainer();
                this.requestRender();
            });
    
            scaleButton.addEventListener('click', () => {
                this.toggleScale = !this.toggleScale;
                this.updateToggleButton(scaleButton, this.toggleScale);
                this.requestRender();
            });
        },
    
        updateToggleButton(button, state) {
            button.classList.toggle('active', state);
            button.textContent = state ? 
                button.textContent.replace('Visa', 'Dölj') : 
                button.textContent.replace('Dölj', 'Visa');
        },
    
        togglePeriodsContainer() {
            const container = document.getElementById('period-labels-container');
            if (this.togglePeriods) {
                container.classList.remove('hidden');
            } else {
                container.classList.add('hidden');
            }
        },
    
        requestRender() {
            if (this.renderRequested) return;
            this.renderRequested = true;
            requestAnimationFrame(() => {
                this.render();
                this.renderRequested = false;
            });
        },
    
        render() {
            this.renderRequested = false;
            this.needsRender = false;
    
            const ctx = ViewportManager.ctx;
            const canvas = ViewportManager.canvas;
    
            // Första beräkningen av placeringar
            const events = EventManager.getVisibleEvents();
            TextPlacementManager.calculatePlacements(ctx, events);
    
            // Beräkna nödvändig kanvashöjd
            const maxLevelsAbove = TextPlacementManager.maxLevelAbove;
            const maxLevelsBelow = TextPlacementManager.maxLevelBelow;
            const totalLevels = maxLevelsAbove + maxLevelsBelow + 1; // +1 för tidslinjen
    
            const verticalSpacing = CONSTANTS.TEXT.VERTICAL_SPACING;
            const requiredHeight = totalLevels * verticalSpacing + (2 * verticalSpacing); // Extra padding
    
            // Justera kanvasens höjd om det behövs
            const currentHeight = canvas.height / window.devicePixelRatio;
            if (currentHeight !== requiredHeight) {
                ViewportManager.adjustCanvasHeight(requiredHeight);
                // Recalculera placeringar med den nya höjden
                TextPlacementManager.calculatePlacements(ctx, events);
            }
    
            const width = canvas.width / window.devicePixelRatio;
            const height = canvas.height / window.devicePixelRatio;
    
            // Rensa canvas
            ctx.clearRect(0, 0, width, height);
    
            this.renderPeriods(ctx, width, height);
            this.renderMainLine(ctx, width, height);
    
            if (this.toggleScale) {
                this.renderScale(ctx, width, height);
            }
    
            this.renderEvents(ctx, width, height);
        },
    
        renderPeriods(ctx, width, height) {
    const container = document.getElementById('period-labels-container');
    container.style.height = `${height}px`; // Sätt explicit höjd
    
    if (!this.togglePeriods) {
        container.innerHTML = '';
        container.classList.add('hidden');
        return;
    } else {
        container.classList.remove('hidden');
    }
    
            // Rensa container innan ny rendering
            container.innerHTML = '';
    
            PERIODS.forEach(period => {
                const startX = ViewportManager.yearToPixel(period.start);
                const endX = ViewportManager.yearToPixel(period.end);
    
                // Rita perioden endast om den är inom canvasens synliga område
                if (Math.min(startX, endX) <= width && Math.max(startX, endX) >= 0) {
                    ctx.fillStyle = period.color;
                    ctx.fillRect(Math.min(startX, endX), 0, Math.abs(endX - startX), height);
    
                    // Skapa en label för perioden
                    const label = document.createElement('div');
                    label.className = 'period-label';
                    label.style.color = period.textColor;
                    label.textContent = period.name;
    
                    const centerX = (startX + endX) / 2;
                    label.style.left = `${centerX}px`;
                    label.style.transform = 'translate(-50%, 0)';
                    label.style.fontSize = `14px`;
                    label.style.fontWeight = '500';
    
                    // Bestäm y-position för att undvika överlappning
                    let level = 0;
                    const spacing = 20; // Avstånd mellan nivåer i pixlar
                    let isAbove = true; // Börja med ovanför tidslinjen
    
                    // Funktion för att hitta nästa tillgängliga nivå
                    const findAvailableLevel = (levels) => {
                        const MAX_LABEL_LEVELS = CONSTANTS.TEXT.MAX_LEVELS; // Definiera en maximal nivå
                        while (levels.some(existingX => Math.abs(existingX - centerX) < 100)) { // Justera 100 efter behov
                            level++;
                            if (level >= MAX_LABEL_LEVELS) {
                                console.warn(`Maximal nivå uppnådd för etikett: ${period.name}`);
                                break; // Bryt loopen för att undvika oändlig loop
                            }
                        }
                        levels.push(centerX);
                        return level;
                    };
    
                    // Skapa nivåer ovanför och under tidslinjen
                    const labelLevelsAbove = []; // Skapa nivåer ovanför
                    const labelLevelsBelow = []; // Skapa nivåer under
    
                    level = findAvailableLevel(isAbove ? labelLevelsAbove : labelLevelsBelow);
    
                    if (isAbove) {
                        // Placera etiketten ovanför tidslinjen
                        label.style.top = `${10 + level * spacing}px`; // Justera efter behov
                    } else {
                        // Placera etiketten under tidslinjen
                        label.style.top = `${height - 10 - level * spacing}px`; // Justera efter behov
                    }
    
                    // Temporärt lägg till i DOM för att mäta bredd
                    container.appendChild(label);
                    const labelWidth = label.offsetWidth;
    
                    if (centerX - labelWidth / 2 < 0) {
                        label.style.left = `${labelWidth / 2}px`;
                    } else if (centerX + labelWidth / 2 > width) {
                        label.style.left = `${width - labelWidth / 2}px`;
                    }
    
                    // Om endast Kvartär är synlig, säkerställ att etiketten alltid visas
                    const visiblePeriods = PERIODS.filter(p => 
                        Math.min(ViewportManager.yearToPixel(p.start), ViewportManager.yearToPixel(p.end)) <= width &&
                        Math.max(ViewportManager.yearToPixel(p.start), ViewportManager.yearToPixel(p.end)) >= 0
                    );
    
                    const isOnlyQuartary = visiblePeriods.length === 1 && period.name === 'Kvartär';
    
                    if (isOnlyQuartary) {
                        label.style.top = `${height / 2 - 30}px`; // Placera etiketten ovanför tidslinjen
                    }
                }
            });
        },
    
        renderMainLine(ctx, width, height) {
            const centerY = height / 2;
            
            ctx.save();
            ctx.beginPath();
            ctx.moveTo(0, centerY);
            ctx.lineTo(width, centerY);
            ctx.strokeStyle = '#555';
            ctx.lineWidth = 4;
            ctx.stroke();
            ctx.restore();
        },
    
        renderScale(ctx, width, height) {
            const timespan = ViewportManager.state.endYear - ViewportManager.state.startYear;
            const magnitude = Math.floor(Math.log10(timespan));
            const normalized = timespan / Math.pow(10, magnitude);
            
            let step;
            if (normalized <= 2) step = 0.2 * Math.pow(10, magnitude);
            else if (normalized <= 5) step = 0.5 * Math.pow(10, magnitude);
            else step = Math.pow(10, magnitude);
            
            const startYear = Math.ceil(ViewportManager.state.startYear / step) * step;
            const centerY = height / 2;
            
            ctx.save();
            ctx.font = '12px Inter';
            ctx.fillStyle = '#666';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
    
            for (let year = startYear; year <= ViewportManager.state.endYear; year += step) {
                const x = ViewportManager.yearToPixel(year);
                
                if (x >= 0 && x <= width) {
                    // Rita skalstreck
                    ctx.beginPath();
                    ctx.moveTo(x, centerY - 5);
                    ctx.lineTo(x, centerY + 5);
                    ctx.strokeStyle = '#666';
                    ctx.lineWidth = 1;
                    ctx.stroke();
                    
                    // Rita årtal
                    ctx.fillText(year.toLocaleString(), x, centerY + 25);
                }
            }
    
            ctx.restore();
        },
    
        renderEvents(ctx, width, height) {
            const events = EventManager.getVisibleEvents();
            if (!events.length) return;
    
            const placements = TextPlacementManager.calculatePlacements(ctx, events);
            const selectedId = EventManager.getSelectedEventId();
            const centerY = height / 2;
    
            events.forEach(event => {
                const x = ViewportManager.yearToPixel(event.yearsAgo);
                const isSelected = event.id === selectedId;
                const isHovered = event.isHovered;
    
                ctx.save();
    
                // Lägg till skuggor och ändra storlek vid hover
                ctx.shadowColor = 'rgba(0, 0, 0, 0.3)';
                ctx.shadowBlur = isHovered ? 15 : 10;
    
                ctx.beginPath();
                ctx.arc(x, centerY, isSelected || isHovered ? 10 : 8, 0, Math.PI * 2);
                ctx.fillStyle = event.color;
                ctx.fill();
    
                ctx.lineWidth = isHovered ? 3 : 2;
                ctx.strokeStyle = isHovered ? 'rgba(255, 255, 255, 0.4)' : 'rgba(255, 255, 255, 0.2)';
                ctx.stroke();
    
                ctx.restore();
    
                // Rita text om placering finns
                const placement = placements.get(event.id);
                if (placement) {
                    this.renderEventText(ctx, event, placement, isSelected || isHovered);
                }
            });
        },
    
        renderEventText(ctx, event, placement, isSelected) {
            const { x, y, isAbove } = placement;
            const centerY = ctx.canvas.height / window.devicePixelRatio / 2;
    
            // Rita kopplingslinjen först så den hamnar under boxen
            ctx.beginPath();
            ctx.moveTo(x, centerY);
            
            // Använd Bezier-kurva för mjukare linjer
            const controlY = isAbove ? 
                y + placement.height / 2 + 20 : 
                y - placement.height / 2 - 20;
            
            ctx.bezierCurveTo(
                x, centerY,
                x, controlY,
                x, y + (isAbove ? placement.height / 2 : -placement.height / 2)
            );
            
            ctx.strokeStyle = event.color;
            ctx.lineWidth = 2;
            ctx.stroke();
    
            // Rita bakgrundsbox
            ctx.save();
            ctx.fillStyle = 'rgba(30, 30, 30, 0.95)';
            ctx.strokeStyle = event.color;
            ctx.lineWidth = 2;
            ctx.shadowColor = 'rgba(0, 0, 0, 0.5)';
            ctx.shadowBlur = 8;
            ctx.shadowOffsetX = 0;
            ctx.shadowOffsetY = 2;
    
            // Rita boxen med rundade hörn
            ctx.beginPath();
            if (ctx.roundRect) {
                ctx.roundRect(
                    x - placement.width / 2,
                    y - placement.height / 2,
                    placement.width,
                    placement.height,
                    8
                );
            } else {
                // Polyfill för äldre webbläsare
                const radius = 8;
                ctx.moveTo(x - placement.width / 2 + radius, y - placement.height / 2);
                ctx.lineTo(x + placement.width / 2 - radius, y - placement.height / 2);
                ctx.quadraticCurveTo(x + placement.width / 2, y - placement.height / 2, x + placement.width / 2, y - placement.height / 2 + radius);
                ctx.lineTo(x + placement.width / 2, y + placement.height / 2 - radius);
                ctx.quadraticCurveTo(x + placement.width / 2, y + placement.height / 2, x + placement.width / 2 - radius, y + placement.height / 2);
                ctx.lineTo(x - placement.width / 2 + radius, y + placement.height / 2);
                ctx.quadraticCurveTo(x - placement.width / 2, y + placement.height / 2, x - placement.width / 2, y + placement.height / 2 - radius);
                ctx.lineTo(x - placement.width / 2, y - placement.height / 2 + radius);
                ctx.quadraticCurveTo(x - placement.width / 2, y - placement.height / 2, x - placement.width / 2 + radius, y - placement.height / 2);
            }
            ctx.fill();
            ctx.stroke();
            ctx.restore();
    
            // Rita texten
            ctx.save();
            ctx.font = `${isSelected ? 'bold ' : ''}14px Inter`;
            ctx.fillStyle = '#fff';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(event.name, x, y - 10);
            ctx.fillText(`${event.yearsAgo.toLocaleString()} år`, x, y + 10);
            ctx.restore();
        }
    };
    
    // Initialisering när dokumentet är laddat
    document.addEventListener('DOMContentLoaded', () => {
        const canvas = document.getElementById('timeline');
        
        // Initiera i rätt ordning
        ViewportManager.initialize(canvas);
        EventManager.initialize();
        TimelineRenderer.initialize();
        
        // Lägg till klickhantering på canvas
        canvas.addEventListener('click', (e) => {
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            EventManager.handleCanvasClick(x, y);
        });
    
        // Första rendering
        TimelineRenderer.requestRender();
    });
    </script>
</body>
</html>
